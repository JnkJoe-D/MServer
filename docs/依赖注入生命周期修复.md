# 依赖注入生命周期问题修复

## 问题描述

### 原始问题

在之前的实现中存在**严重的依赖注入生命周期不匹配问题**：

```csharp
// ❌ 错误的实现
public class MessageHandlerRegistration : IHostedService
{
    public Task StartAsync(CancellationToken cancellationToken)
    {
        using var scope = _provider.CreateScope();
        
        // 问题：从临时 scope 中获取 Scoped 的 Handler 实例
        var handler = scope.ServiceProvider.GetRequiredService<LoginHandler>();
        
        // 问题：将 Scoped 实例注册给 Singleton 的 Gateway
        _gateway.RegisterHandler(MsgId.Login, handler);
        
        return Task.CompletedTask;
    }
    // ← scope 在这里被释放，但 handler 实例仍被 Gateway 持有！
}
```

### 问题链

```
MessageHandlerRegistration (Singleton)
    ↓ 从临时 scope 获取
LoginHandler (Scoped) ← 被长期持有！
    ↓ 构造函数注入
GameDbContext (Scoped) ← 永不释放！
```

### 严重后果

1. **DbContext 永不释放**
   - 数据库连接不释放
   - 连接池耗尽
   - 内存泄漏

2. **EF Core 变更跟踪器污染**
   - 所有消息共享同一个 DbContext
   - 实体状态混乱
   - 可能产生脏数据

3. **线程安全问题**
   - DbContext 不是线程安全的
   - 并发消息会导致异常

## 解决方案

### 核心思路

**MessageGateway 不应持有处理器实例，而应持有处理器类型（Type）**。每次处理消息时：

1. 创建新的 `IServiceScope`
2. 从新 Scope 中解析处理器实例
3. 执行完毕后释放 Scope
4. 确保 DbContext 等 Scoped 服务正确释放

### 修复后的实现

#### 1. MessageGateway.cs

```csharp
public class MessageGateway
{
    // ✅ 持有 Type，而不是实例
    private readonly Dictionary<ushort, Type> _handlerTypes = new();
    private readonly IServiceProvider _serviceProvider;

    // ✅ 注册类型
    public void RegisterHandler<THandler>(ushort msgId) where THandler : IMessageHandler
    {
        _handlerTypes[msgId] = typeof(THandler);
    }

    public async Task RouteMessageAsync(IAppSession session, GamePackage package)
    {
        if (!_handlerTypes.TryGetValue(package.MsgId, out var handlerType))
            return;

        // ✅ 每次处理消息时创建新的 Scope
        using var scope = _serviceProvider.CreateScope();
        
        // ✅ 从新 Scope 中解析实例
        var handler = scope.ServiceProvider.GetRequiredService(handlerType) as IMessageHandler;
        
        await handler.HandleAsync(session, package.Payload);
        
        // ✅ Scope 结束时自动释放 Handler 和 DbContext
    }
}
```

#### 2. Program.cs

```csharp
public class MessageHandlerRegistration : IHostedService
{
    private readonly MessageGateway _gateway;

    public Task StartAsync(CancellationToken cancellationToken)
    {
        // ✅ 注册类型，不创建实例
        _gateway.RegisterHandler<LoginHandler>(MsgId.Login);
        _gateway.RegisterHandler<RegisterHandler>(MsgId.Register);
        _gateway.RegisterHandler<CreatePlayerHandler>(MsgId.CreatePlayer);
        _gateway.RegisterHandler<GetPlayerListHandler>(MsgId.GetPlayerList);

        return Task.CompletedTask;
    }
}
```

## 生命周期对比

### 修复前（❌ 错误）

```
启动时：
  └─ Scope A (创建)
      └─ LoginHandler 实例 (Scoped)
          └─ DbContext 实例 (Scoped)
  └─ Scope A (释放) ← 但实例仍被 Gateway 持有！

消息1：使用被持有的实例
消息2：使用被持有的实例  ← DbContext 被重复使用！
消息3：使用被持有的实例
...
服务器关闭：DbContext 才被释放
```

### 修复后（✅ 正确）

```
消息1：
  └─ Scope 1 (创建)
      └─ LoginHandler 实例1 (Scoped)
          └─ DbContext 实例1 (Scoped)
  └─ Scope 1 (释放) ← 实例1 和 DbContext1 被释放

消息2：
  └─ Scope 2 (创建)
      └─ LoginHandler 实例2 (Scoped)
          └─ DbContext 实例2 (Scoped)
  └─ Scope 2 (释放) ← 实例2 和 DbContext2 被释放

每个消息都有独立的 Handler 和 DbContext！
```

## .NET 依赖注入生命周期

| 生命周期 | 注册方法 | 特点 |
|---------|---------|------|
| **Transient** | `AddTransient<T>()` | 每次请求都创建新实例 |
| **Scoped** | `AddScoped<T>()` | 每个 Scope 内单例 |
| **Singleton** | `AddSingleton<T>()` | 全局单例 |

### 常见服务的生命周期

| 服务 | 生命周期 | 原因 |
|------|---------|------|
| `DbContext` | **Scoped** | 需要在每次请求后释放连接 |
| `HttpClient` | **Singleton** | 避免端口耗尽 |
| `ILogger<T>` | **Singleton** | 无状态 |
| **Handler**（本项目） | **Scoped** | 注入了 Scoped 的 DbContext |
| **Gateway**（本项目） | **Singleton** | 全局路由器 |

## 验证修复

### 测试代码

```csharp
[Fact]
public async Task Handler_ShouldHaveIndependentDbContext()
{
    // 模拟两个并发消息
    var task1 = gateway.RouteMessageAsync(session, package1);
    var task2 = gateway.RouteMessageAsync(session, package2);
    
    await Task.WhenAll(task1, task2);
    
    // 验证：两个消息应该使用不同的 DbContext 实例
    Assert.NotSame(dbContext1, dbContext2);
}
```

### 监控指标

- **数据库连接数**：应该保持稳定，不会持续增长
- **内存使用**：应该在消息处理后释放
- **并发安全**：不应出现 DbContext 并发访问异常

## 最佳实践总结

1. **Singleton 不应直接持有 Scoped 实例**
   - 使用 Type 或工厂模式
   
2. **每次请求创建新的 Scope**
   - 确保 Scoped 服务生命周期正确
   
3. **DbContext 必须是 Scoped**
   - 避免连接泄漏和状态污染
   
4. **使用 `using var scope`**
   - 自动释放资源

## 相关资源

- [ASP.NET Core 依赖注入](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/dependency-injection)
- [EF Core DbContext 生命周期](https://learn.microsoft.com/zh-cn/ef/core/dbcontext-configuration/)
- [.NET 服务生命周期](https://learn.microsoft.com/zh-cn/dotnet/core/extensions/dependency-injection#service-lifetimes)
